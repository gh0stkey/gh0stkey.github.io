<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>读取型CSRF-需要交互的内容劫持 · Chen's Blog</title> <meta name="description" content="前言"> <link rel="icon" href="http://localhost:4000/assets/favicon.png"> <link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png"> <link rel="stylesheet" href="http://localhost:4000/assets/core.css"> <link rel="canonical" href="http://localhost:4000/archives/2018-03-22/1"> <link rel="alternate" type="application/atom+xml" title="Chen's Blog" href="http://localhost:4000/feed.xml" /> <link href="/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" media="all" /> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e4a42a371cc5994ee02b940034c29658"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <aside class="logo"> <a href="http://localhost:4000/"> <img src="/assets/avatar.jpg" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <article> <h1 class="title">ᴀᴜᴛʜᴏʀ: ᴠᴜʟᴋᴇʏ_ᴄʜᴇɴ</h1> <div class="divider"></div> <center><a href="/about" target="_blank">ᴀʙᴏᴜᴛ</a> | <a href="/links" target="_blank">ʟɪɴᴋs</a> | <a href="/AssistTool" target="_blank">ᴀssɪsᴛ ᴛᴏᴏʟ</a> | <a href="/RGPerson" target="_blank">ʀɢᴘᴇʀsᴏɴ</a> | <a href="/Binary-Learning" target="_blank">ʙɪɴᴀʀʏ ʟᴇᴀʀɴɪɴɢ</a></center> <div class="divider"></div> </article> <div id="content"> <article> <div class="center"> <h1 class="title">读取型CSRF-需要交互的内容劫持</h1> <time class="code">March 22, 2018</time> </div> <div class="divider"></div> <h1 id="前言">前言</h1> <p>最近在挖洞，”实践出真知”这句话说的很对，在实际挖掘过程中我会思考很多东西，跟朋友一起准备做一份手册，忽然的想到了一些漏洞的定义和规范。 在大多数的人眼里CSRF可能仅仅是<strong>写入型</strong>的比如：修改个人资料、授权登陆等等功能场景的CSRF问题，同时对CSRF这类问题进行了危害等级划分，就像如上两个例子，可以划分为中危和高危。也许是因为交互式的漏洞并没有SQLi这种直接能利用的漏洞危害高，所以一些厂商对CSRF也并不重视。</p> <p>步入正题，什么是读取型CSRF，这里我对如下的漏洞归纳进了读取型CSRF，因为这些漏洞的利用手法都跟CSRF是一样的：</p> <ul> <li>JSONP劫持</li> <li>Flash跨域劫持</li> <li>CORS跨域资源读取</li> </ul> <p>…等等，当然还有Silverlight跨域这些了，不过这里只列举常见的三种来讲解。</p> <h1 id="读取型csrf">读取型CSRF</h1> <p>接下以如上所说的三个漏洞案例来一个个分析。</p> <h2 id="jsonp劫持">JSONP劫持</h2> <h3 id="漏洞案例">漏洞案例</h3> <p>这里来看一条请求：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x00.png" alt="jsonp hijacking" /></p> <p>这条请求返回的结果中有手机号（这里我测试的账号没绑定手机），如果我们想要以CSRF交互式攻击的方式获取这个手机号该怎么办？</p> <p>来看看这条请求有callback，而返回结果是不是类似Javascript中的函数？</p> <p>Javascript原函数定义如下：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">funName</span><span class="p">(){}</span>
</code></pre></div></div> <p>这里是缺少了函数定义的关键词<code class="language-plaintext highlighter-rouge">function</code>和花括号的函数主体部分，只有函数名和函数传参，聪明人已经想到了，这不就相当于是自定义函数被引用了么，而中间那段传参就相当于是一个数组，所以我们可以先用JS自定义好这个函数，然后再引用这个请求，自然就可以获取到数据了。</p> <p>这时候我们可以来构建一下PoC：</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 引用一段如上请求为JS --&gt;</span>
<span class="nt">&lt;script&gt;</span><span class="kd">function</span> <span class="nx">jsonp2</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span><span class="nx">alert</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">));}</span><span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"http://gh0st.cn/user/center?callback=jsonp2"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div> <p>使用正常的账号(绑定过手机号)来测试下：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x01.png" alt="jsonp hijacking" /></p> <h3 id="案例总结">案例总结</h3> <p>其实通过这个例子，我们可以知道HTML标签<code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>在一定的情况下是可以跨域读取的。</p> <p>对此漏洞的修复有很多：</p> <p>1.打乱响应主体内容</p> <p>2.Referer等进行限制</p> <p>…..等等</p> <h2 id="flash跨域劫持">Flash跨域劫持</h2> <p>Flash跨域比较经典了，在做web目录资产整理的时候有时候会发现这样的文件 <strong>crossdomain.xml</strong> ，文件内容如果是如下的，那么就存在Flash跨域问题，如下内容的意思是支持所有域：</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0"?&gt;</span>
<span class="nt">&lt;cross-domain-policy&gt;</span>
  <span class="nt">&lt;allow-access-from</span> <span class="na">domain=</span><span class="s">"*"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/cross-domain-policy&gt;</span>
</code></pre></div></div> <p>为什么会如此？具体流程是这样的：</p> <p>gh0st.cn 有一个SWF文件，这个文件是想要获取 vulkey.cn 的 userinfo 的返回响应主体，SWF首先会看在 vulkey.cn 的服务器目录下有没有 <strong>crossdomain.xml</strong> 文件，如果没有就会访问不成功，如果有 <strong>crossdomain.xml</strong> ，则会看<strong>crossdomain.xml</strong> 文件的内容里面是否设置了允许 gh0st.cn 域访问，如果设置允许了，那么 gh0st.cn 的SWF文件就可以成功获取到内容。所以要使Flash可以跨域传输数据，其关键就是<strong>crossdomain.xml</strong> 文件。</p> <p>当你发现 <strong>crossdomain.xml</strong> 文件的内容为我如上所示的内容，那么就是存在Flash跨域劫持的。</p> <h3 id="漏洞案例-1">漏洞案例</h3> <p>在对一个厂商进行测试的时候正好发现了这样的文件：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x02.png" alt="flash hijacking" /></p> <p>在这里我需要做两件事：</p> <p>1.找到一个能获取敏感信息的接口</p> <p>2.构建PoC</p> <p>在这里敏感的信息接口以个人中心为例子，PoC使用的是 https://github.com/nccgroup/CrossSiteContentHijacking/raw/master/ContentHijacking/objects/ContentHijacking.swf</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x03.png" alt="flash hijacking" /></p> <h3 id="案例总结-1">案例总结</h3> <p>很简单的一个东西，但是用处却很大，其利用方法跟CSRF也是一样的，只需要修改下PoC就行。</p> <p>修复方案同样也很简单，针对<code class="language-plaintext highlighter-rouge">&lt;allow-access-from domain="*" /&gt;</code>的domain进行调整即可。</p> <h2 id="cors跨域资源读取">CORS跨域资源读取</h2> <h3 id="漏洞案例-2">漏洞案例</h3> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x04.png" alt="CORS" /></p> <p>如上图中我在请求的时候加上了请求头 <code class="language-plaintext highlighter-rouge">Origin: http://gh0st.cn</code>，而对应的响应包中出现了<code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin: http://gh0st.cn</code>这个响应头其实就是访问控制允许，在这里是允许http://gh0st.cn的请求的，所以http://gh0st.cn是可以跨域读取此网址的内容的~在这里我介绍下<code class="language-plaintext highlighter-rouge">Origin</code>：</p> <p><code class="language-plaintext highlighter-rouge">Origin</code>和<code class="language-plaintext highlighter-rouge">Referer</code>很相似，就是将当前的请求参数删除，仅剩下<strong>三元组（协议 主机 端口）</strong>，标准的浏览器，会在每次请求中都带上<code class="language-plaintext highlighter-rouge">Origin</code>，至少在跨域操作时肯定携带（例如ajax的操作）。</p> <p>所以要测试是否存在CORS这个问题就可以参考我上面的操作手法了。</p> <p>怎么利用呢？在这里我使用了github上的开源项目:https://github.com/nccgroup/CrossSiteContentHijacking，readme.md中有具体的说明，这里我就不一一讲解了，那么已经确认问题了，那就需要进一步的验证。</p> <p>在这里我找到了一处接口，其响应主体内容是获取用户的真实姓名、身份证、手机号等内容：</p> <p>/daren/author/query （要注意的是这个请求在抓取的时候是POST请求方式，但并没有请求正文，经过测试请求正文为任意内容即可）</p> <p>响应报文正文内容：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x05.png" alt="CORS" /></p> <p>这里CrossSiteContentHijacking项目我搭建在了本地(127.0.0.1) http://127.0.0.1/CrossSiteContentHijacking/ContentHijackingLoader.html</p> <p>根据项目所说的操作去进行参数的配置，然后点击 Retrieve Contents 按钮：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x06.png" alt="CORS" /></p> <p>测试如下，测试结果是可以跨域读取的：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2018-03-22/0x07.png" alt="CORS" /></p> <h3 id="案例总结-2">案例总结</h3> <p>这个问题其实就是对Origin的验证没有控制好，对其进行加强即可。</p> <h1 id="结尾">结尾</h1> <p>结尾想说的东西其实也没什么了，总结了这些东西希望能帮助到各位~</p> </article> <div class="page-navigation code"> <a class="next" href="http://localhost:4000/archives/2018-04-08/1" title="NEXT: 二维码登陆的常见缺陷剖析">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="http://localhost:4000/" title="Back to Index">INDEX</a> <span> &middot; </span> <a class="prev" href="http://localhost:4000/archives/2018-02-12/1" title="PREV: OAuth2.0认证缺陷-第三方帐号快捷登录授权劫持漏洞">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-2021</span> </div> <script src="/fancybox/lib/jquery-1.10.2.min.js"></script> <script type="text/javascript" src="/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script> <script> $(document).ready(function() { $("article img").each(function() { var strA = "<a style='text-decoration: none;' id='imgid' href='" + this.src + "'></a>"; $(this).wrapAll(strA); }); $(".block").html("&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-" + (new Date()).getFullYear()); }); $("#imgid").fancybox({ openEffect : 'elastic', closeEffect : 'elastic', }); </script> </body> </html>
